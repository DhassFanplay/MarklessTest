<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Floor Detection - Point Cloud</title>

  <!-- A-Frame + OpenCV -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script async src="https://docs.opencv.org/4.5.0/opencv.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
    }
    .overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
    }
    #cameraSelect, #startButton {
      display: block;
      margin: 10px auto;
      padding: 15px 30px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      cursor: pointer;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 20;
    }
  </style>
</head>

<body>

<!-- UI -->
<div class="overlay">
  <select id="cameraSelect"><option value="">Select Camera</option></select>
  <button id="startButton" style="display: none;">Start Camera</button>
</div>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<!-- A-Frame Scene -->
<a-scene embedded>
  <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
  <a-entity light="type: directional; intensity: 0.7;" position="1 2 1"></a-entity>
  <a-entity camera look-controls></a-entity>
</a-scene>

<script>
  const cameraSelect = document.getElementById('cameraSelect');
  const startButton = document.getElementById('startButton');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const scene = document.querySelector('a-scene');

  let placed = false;

  const checkCv = setInterval(() => {
    if (typeof cv !== 'undefined') {
      clearInterval(checkCv);
      getCameras();
    }
  }, 100);

  async function getCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      cameraSelect.innerHTML = '<option value="">Select Camera</option>';
      videoDevices.forEach((device, i) => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = `Camera ${i + 1} (${device.label || 'No label'})`;
        cameraSelect.appendChild(option);
      });
      cameraSelect.onchange = () => {
        startButton.style.display = cameraSelect.value ? 'block' : 'none';
      };
    } catch (err) {
      alert("Failed to list cameras");
      console.error(err);
    }
  }

  startButton.addEventListener('click', () => {
    switchCamera(cameraSelect.value);
  });

  async function switchCamera(cameraId) {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: { exact: cameraId }, width: { ideal: 640 }, height: { ideal: 480 } }
      });
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        requestAnimationFrame(processFrame);
      };
    } catch (err) {
      alert("Camera access failed.");
      console.error(err);
    }
  }

  function addPointToScene(xNorm, yNorm) {
    const z = -1.5; // fixed depth
    const point = document.createElement('a-sphere');
    point.setAttribute('radius', '0.03');
    point.setAttribute('color', '#00ffcc');
    point.setAttribute('position', `${xNorm} 0 ${z + yNorm}`); // floor plane approximation
    scene.appendChild(point);
  }

  function processFrame() {
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(processFrame);
      return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    try {
      const src = cv.imread(canvas);
      const gray = new cv.Mat();
      const edges = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.Canny(gray, edges, 50, 150);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const gridSize = 8;

      for (let i = 0; i < contours.size(); ++i) {
        const cnt = contours.get(i);
        if (cv.contourArea(cnt) > 8000 && !placed) {
          const rect = cv.boundingRect(cnt);
          for (let gx = 1; gx < gridSize; gx++) {
            for (let gy = 1; gy < gridSize; gy++) {
              const px = rect.x + (gx * rect.width / gridSize);
              const py = rect.y + (gy * rect.height / gridSize);
              const inside = cv.pointPolygonTest(cnt, new cv.Point(px, py), false);
              if (inside >= 0) {
                const xNorm = (px / canvas.width) * 2 - 1;
                const yNorm = (py / canvas.height) * 2 - 1;
                addPointToScene(xNorm, yNorm);
              }
            }
          }
          placed = true;
        }
      }

      src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    } catch (err) {
      console.error("OpenCV error:", err);
    }

    requestAnimationFrame(processFrame);
  }
</script>

</body>
</html>
