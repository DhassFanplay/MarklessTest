<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Floor Detection with 3D Points</title>

  <!-- A-Frame and OpenCV.js -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script async src="https://docs.opencv.org/4.5.0/opencv.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
    }
    .overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
    }
    #cameraSelect, #startButton {
      display: block;
      margin: 10px auto;
      padding: 15px 30px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      cursor: pointer;
    }
    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 20;
    }
    #reticle {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid lime;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 30;
      pointer-events: none;
    }
  </style>
</head>
<body>

<!-- UI -->
<div class="overlay" id="uiOverlay">
  <select id="cameraSelect">
    <option value="">Select Camera</option>
  </select>
  <button id="startButton" style="display: none;">Start Camera</button>
</div>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<div id="reticle"></div>

<!-- A-Frame Scene -->
<a-scene embedded>
  <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
  <a-entity light="type: directional; color: #fff; intensity: 0.7;" position="-1 1 0"></a-entity>
  <a-entity camera look-controls></a-entity>
</a-scene>

<script>
  const cameraSelect = document.getElementById('cameraSelect');
  const startButton = document.getElementById('startButton');
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const scene = document.querySelector('a-scene');

  let isPlaced = false;

  // Wait for OpenCV
  const checkCv = setInterval(() => {
    if (typeof cv !== 'undefined') {
      clearInterval(checkCv);
      getCameras();
    }
  }, 100);

  async function getCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');

      if (videoDevices.length > 0) {
        cameraSelect.innerHTML = '<option value="">Select Camera</option>';
        videoDevices.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId || '';
          option.text = `Camera ${index + 1} (${device.label || 'No label'})`;
          cameraSelect.appendChild(option);
        });

        cameraSelect.style.display = 'block';
        cameraSelect.addEventListener('change', () => {
          if (cameraSelect.value) startButton.style.display = 'block';
        });
      } else {
        alert("No cameras found.");
      }
    } catch (err) {
      console.error("Error enumerating devices:", err);
      alert("Could not retrieve camera list.");
    }
  }

  startButton.addEventListener('click', () => {
    const selectedCamera = cameraSelect.value;
    if (!selectedCamera) {
      alert("Please select a valid camera.");
      return;
    }
    switchCamera(selectedCamera);
  });

  async function switchCamera(cameraId) {
    const constraints = {
      video: {
        deviceId: cameraId ? { exact: cameraId } : undefined,
        width: { ideal: 640 },
        height: { ideal: 480 }
      }
    };

    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      video.onloadedmetadata = () => {
        video.play().catch(err => console.error("Video play error:", err));
      };

      startButton.style.display = 'none';
      requestAnimationFrame(processFrame);
    } catch (err) {
      console.error("Camera error:", err);
      alert("Could not start camera.");
    }
  }

  function addMarkerInScene(xNorm, yNorm) {
    let zDepth = -1 - (yNorm * 0.5); // estimate depth
    const marker = document.createElement('a-sphere');
    marker.setAttribute('radius', '0.05');
    marker.setAttribute('color', 'yellow');
    marker.setAttribute('position', { x: xNorm, y: 0, z: zDepth });
    marker.setAttribute('visible', true);
    scene.appendChild(marker);
  }

  function processFrame() {
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(processFrame);
      return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    try {
      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      let edges = new cv.Mat();

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.Canny(gray, edges, 50, 150);

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const gridSize = 5;

      for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        if (cv.contourArea(cnt) > 8000 && !isPlaced) {
          let rect = cv.boundingRect(cnt);

          ctx.strokeStyle = "lime";
          ctx.lineWidth = 3;
          ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

          for (let gx = 1; gx < gridSize; gx++) {
            for (let gy = 1; gy < gridSize; gy++) {
              const px = rect.x + (gx * rect.width / gridSize);
              const py = rect.y + (gy * rect.height / gridSize);

              const pointInside = cv.pointPolygonTest(cnt, new cv.Point(px, py), false);
              if (pointInside >= 0) {
                let xNorm = (px / canvas.width) * 2 - 1;
                let yNorm = (py / canvas.height) * 2 - 1;
                addMarkerInScene(xNorm, yNorm);
              }
            }
          }

          isPlaced = true;
        }
      }

      src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    } catch (err) {
      console.error("OpenCV Error:", err);
    }

    requestAnimationFrame(processFrame);
  }
</script>

</body>
</html>
