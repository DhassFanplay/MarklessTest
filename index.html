<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Floor Detection - Visual Overlay</title>

  <!-- Load A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js "></script>

  <!-- Load OpenCV.js -->
  <script async src="https://docs.opencv.org/4.5.0/opencv.js "></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
    }

    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
    }

    .overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
    }

    .overlay button {
      display: block;
      margin: 10px auto;
      padding: 15px 30px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      cursor: pointer;
    }

    #rescanButton, #placeCubeButton {
      display: none;
    }

    #debugCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      mix-blend-mode: multiply; /* Makes overlapping colors darker */
    }

    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 20;
    }

    #reticle {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 30;
      pointer-events: none;
    }

    #statusText {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: lime;
      font-size: 16px;
      z-index: 100;
      display: none;
    }
  </style>
</head>

<body>

<!-- Overlay UI -->
<div class="overlay" id="uiOverlay">
  <select id="cameraSelect">
    <option value="">Select Camera</option>
  </select>
  <button id="startButton">Start Camera</button>
  <button id="rescanButton">Rescan Floor</button>
  <button id="placeCubeButton">Place Cube</button>
</div>

<div id="statusText">Looking for floor...</div>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>
<canvas id="debugCanvas"></canvas>
<div id="reticle"></div>

<!-- A-Frame Scene -->
<a-scene embedded arjs='trackingMethod: best;' vr-mode-ui="enabled: false">
  <!-- Lighting -->
  <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
  <a-entity light="type: directional; color: #fff; intensity: 0.7;" position="-1 1 0"></a-entity>

  <!-- Red Cube (hidden initially) -->
  <a-box id="placedCube"
         color="red"
         depth="0.5"
         height="0.5"
         width="0.5"
         visible="false"
         position="0 0 -1">
  </a-box>

  <!-- Camera -->
  <a-entity id="camera" camera look-controls wasd-controls></a-entity>
</a-scene>

<script>
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const debugCanvas = document.getElementById('debugCanvas');
  const debugCtx = debugCanvas.getContext('2d');

  const cameraEl = document.getElementById('camera');
  const cube = document.getElementById('placedCube');

  let isPlaced = false;

  // Wait for OpenCV to load
  const checkCv = setInterval(() => {
    if (typeof cv !== 'undefined') {
      clearInterval(checkCv);
      initCameras();
    }
  }, 100);

  function initCameras() {
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => {
        video.srcObject = stream;
        video.play();
        requestAnimationFrame(processFrame);
      })
      .catch(err => {
        alert("Could not access camera.");
        console.error("Camera error:", err);
      });
  }

  function processFrame() {
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(processFrame);
      return;
    }

    const cw = video.videoWidth;
    const ch = video.videoHeight;

    canvas.width = cw;
    canvas.height = ch;
    debugCanvas.width = cw;
    debugCanvas.height = ch;

    ctx.drawImage(video, 0, 0, cw, ch);
    debugCtx.clearRect(0, 0, cw, ch);

    if (!isPlaced) {
      try {
        let src = cv.imread(canvas);
        let gray = new cv.Mat();
        let edges = new cv.Mat();

        // Convert to grayscale
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        // Canny edge detection
        cv.Canny(gray, edges, 50, 150);

        // Morphological operations
        let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5, 5));
        cv.dilate(edges, edges, kernel, new cv.Point(-1, -1), 5);
        cv.erode(edges, edges, kernel, new cv.Point(-1, -1), 3);

        // Find contours
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // Loop through contours
        for (let i = 0; i < contours.size(); ++i) {
          let cnt = contours.get(i);
          let area = cv.contourArea(cnt);

          if (area > 10000) { // Large enough to be considered floor
            let rect = cv.boundingRect(cnt);
            drawDebugOverlay(rect.x, rect.y, rect.width, rect.height);
          }
        }

        src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
      } catch (err) {
        console.error("OpenCV Error:", err);
      }
    }

    requestAnimationFrame(processFrame);
  }

  // Draw transparent green overlay over floor-like surfaces
  function drawDebugOverlay(x, y, w, h) {
    debugCtx.fillStyle = "rgba(0, 255, 0, 0.3)";
    debugCtx.fillRect(x, y, w, h);
  }

  // Start camera manually
  document.getElementById('startButton').addEventListener('click', () => {
    const selectedCamera = document.getElementById('cameraSelect').value;
    if (!selectedCamera) {
      alert("Please select a valid camera.");
      return;
    }

    navigator.mediaDevices.getUserMedia({
      video: { deviceId: { exact: selectedCamera } }
    }).then(stream => {
      video.srcObject = stream;
      video.onloadedmetadata = () => {
        video.play();
        document.getElementById('startButton').style.display = 'none';
        document.getElementById('rescanButton').style.display = 'block';
        document.getElementById('placeCubeButton').style.display = 'block';
      };
    }).catch(err => {
      alert("Failed to start selected camera.");
      console.error("Camera error:", err);
    });
  });

  // Reset placement
  document.getElementById('rescanButton').addEventListener('click', () => {
    cube.setAttribute('visible', false);
    isPlaced = false;
  });

  // Place cube at screen center if floor detected
  document.getElementById('placeCubeButton').addEventListener('click', () => {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    try {
      let src = cv.imread(canvas);
      let gray = new cv.Mat();
      let edges = new cv.Mat();

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.Canny(gray, edges, 50, 150);

      let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(5, 5));
      cv.dilate(edges, edges, kernel, new cv.Point(-1, -1), 5);
      cv.erode(edges, edges, kernel, new cv.Point(-1, -1), 3);

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let surfaceUnderCenter = false;

      for (let i = 0; i < contours.size(); ++i) {
        let cnt = contours.get(i);
        let rect = cv.boundingRect(cnt);

        if (
          centerX >= rect.x &&
          centerX <= rect.x + rect.width &&
          centerY >= rect.y &&
          centerY <= rect.y + rect.height
        ) {
          surfaceUnderCenter = true;
          break;
        }
      }

      // Cleanup
      src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();

      if (surfaceUnderCenter) {
        // Normalize center point to A-Frame coordinate system (-1 to 1)
        let xNorm = (centerX / canvas.width) * 2 - 1;
        let yNorm = (centerY / canvas.height) * 2 - 1;
        let zDepth = -1 - (yNorm * 0.5);

        cube.setAttribute('position', {
          x: xNorm,
          y: 0,
          z: zDepth
        });

        cube.setAttribute('visible', true);
        isPlaced = true;
      } else {
        alert("No floor under center. Point at flat surface.");
      }

    } catch (err) {
      console.error("OpenCV Error:", err);
    }
  });

  // Populate camera list
  document.getElementById('cameraSelect').addEventListener('change', () => {
    if (document.getElementById('cameraSelect').value) {
      document.getElementById('startButton').style.display = 'block';
    }
  });

  navigator.mediaDevices.enumerateDevices()
    .then(devices => {
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      const select = document.getElementById('cameraSelect');

      videoDevices.forEach((device, index) => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        option.text = `Camera ${index + 1} (${device.label || 'No label'})`;
        select.appendChild(option);
      });
    })
    .catch(err => {
      console.error("Device enumeration failed", err);
    });

  // Reticle logic
  document.body.addEventListener('click', () => {
    if (!isPlaced && document.getElementById('placeCubeButton').style.display !== 'none') {
      document.getElementById('placeCubeButton').click();
    }
  });
</script>

</body>
</html>
