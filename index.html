<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AR Floor Placement - Raycast to Floor</title>

  <!-- Load A-Frame -->
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js "></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
    }

    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      display: none;
    }

    .overlay {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      z-index: 100;
    }

    .overlay button {
      display: block;
      margin: 10px auto;
      padding: 15px 30px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      cursor: pointer;
    }

    #rescanButton, #placeCubeButton {
      display: none;
    }

    a-scene {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 20;
    }

    #reticle {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 30;
      pointer-events: none;
    }

    #statusText {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: lime;
      font-size: 16px;
      z-index: 100;
      display: none;
    }
  </style>
</head>

<body>

<!-- Overlay UI -->
<div class="overlay" id="uiOverlay">
  <select id="cameraSelect">
    <option value="">Select Camera</option>
  </select>
  <button id="startButton">Start Camera</button>
  <button id="rescanButton">Rescan Floor</button>
  <button id="placeCubeButton">Place Cube</button>
</div>

<div id="statusText">Looking for floor...</div>

<video id="video" autoplay playsinline></video>
<div id="reticle"></div>

<!-- A-Frame Scene -->
<a-scene embedded arjs='trackingMethod: best;' vr-mode-ui="enabled: false" device-orientation-permission-ui="enabled: false">
  <!-- Lighting -->
  <a-entity light="type: ambient; intensity: 0.5;"></a-entity>
  <a-entity light="type: directional; color: #fff; intensity: 0.7;" position="-1 1 0"></a-entity>

  <!-- Red Cube (hidden initially) -->
  <a-box id="placedCube"
         color="red"
         depth="0.5"
         height="0.5"
         width="0.5"
         visible="false"
         position="0 0 -1">
  </a-box>

  <!-- Floor Plane (invisible) -->
  <a-plane id="floorPlane"
           rotation="-90 0 0"
           height="100"
           width="100"
           visible="false"
           position="0 -0.01 0"
           material="opacity: 0.01;"></a-plane>

  <!-- Camera -->
  <a-entity id="camera" camera look-controls wasd-controls position="0 1.6 0"></a-entity>
</a-scene>

<script>
  const video = document.getElementById('video');
  const cameraSelect = document.getElementById('cameraSelect');
  const startButton = document.getElementById('startButton');
  const rescanButton = document.getElementById('rescanButton');
  const placeCubeButton = document.getElementById('placeCubeButton');
  const cube = document.getElementById('placedCube');
  const floorPlane = document.getElementById('floorPlane');

  let isPlaced = false;

  // Wait for devices to be available
  navigator.mediaDevices.enumerateDevices()
    .then(devices => {
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      if (videoDevices.length > 0) {
        cameraSelect.innerHTML = '<option value="">Select Camera</option>';
        videoDevices.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId || '';
          option.text = `Camera ${index + 1} (${device.label || 'No label'})`;
          cameraSelect.appendChild(option);
        });
        cameraSelect.style.display = 'block';
        cameraSelect.addEventListener('change', () => {
          if (cameraSelect.value) {
            startButton.style.display = 'block';
          } else {
            startButton.style.display = 'none';
          }
        });
      } else {
        alert("No cameras found.");
      }
    })
    .catch(err => {
      console.error("Device enumeration failed", err);
    });

  // Start selected camera manually
  startButton.addEventListener('click', () => {
    const selectedCamera = cameraSelect.value;
    const constraints = {
      video: {}
    };

    if (selectedCamera && selectedCamera.trim() !== '') {
      constraints.video.deviceId = { exact: selectedCamera };
    }

    navigator.mediaDevices.getUserMedia(constraints)
      .then(stream => {
        video.srcObject = stream;
        video.play();

        video.style.display = 'block';

        startButton.style.display = 'none';
        rescanButton.style.display = 'block';
        placeCubeButton.style.display = 'block';
      })
      .catch(err => {
        alert("Failed to open selected camera.");
        console.error("Camera error:", err);
      });
  });

  // Reset cube placement and resume detection
  rescanButton.addEventListener('click', () => {
    cube.setAttribute('visible', false);
    isPlaced = false;
    statusText.textContent = "Looking for floor...";
    statusText.style.display = 'block';
    setTimeout(() => statusText.style.display = 'none', 2000);
  });

  // Place cube where camera is pointing at floor
  placeCubeButton.addEventListener('click', () => {
    const cameraEl = document.getElementById('camera');
    const camera = cameraEl.getObject3D('camera');
    const scene = document.querySelector('a-scene').object3D;

    if (!camera) {
      alert("Camera not ready yet.");
      return;
    }

    // Create raycaster from center of screen
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

    // Define floor plane at Y = 0
    const floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // Y=0 floor
    const intersectPoint = new THREE.Vector3();
    const intersects = raycaster.intersectPlane(floorPlane, intersectPoint);

    if (intersects) {
      // Set cube position to intersection point
      cube.setAttribute('position', {
        x: intersectPoint.x,
        y: 0.25, // Slight lift so it doesn't clip
        z: intersectPoint.z
      });

      cube.setAttribute('visible', true);
      isPlaced = true;
      statusText.textContent = "Cube placed.";
      statusText.style.display = 'block';
      setTimeout(() => statusText.style.display = 'none', 2000);
    } else {
      alert("No floor under center. Try again.");
    }
  });

  // Utility: Get longest line (for floor edge lines)
  function getBestLine(lines) {
    if (lines.length === 0) return null;
    return lines.reduce((a, b) => {
      let lenA = Math.hypot(a.x2 - a.x1, a.y2 - a.y1);
      let lenB = Math.hypot(b.x2 - b.x1, b.y2 - b.y1);
      return lenA > lenB ? a : b;
    });
  }
</script>

</body>
</html>
